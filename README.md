Data Structures and Algorithms (DSA) Projects
Introduction
This repository contains implementations of essential data structures and algorithms. Each project includes both code and explanations to help understand the underlying concepts. The projects are designed to cover various DSA topics like searching, sorting, dynamic programming, and graph algorithms.

Table of Contents
Binary Search Tree Operations
AVL Tree (Self-Balancing Binary Search Tree)
Heap (Min Heap & Max Heap) Implementation
Trie Data Structure (Prefix Tree)
Graph (Adjacency List Representation)
Dijkstra’s Shortest Path Algorithm
Topological Sorting (Directed Acyclic Graph)
Dynamic Programming - Longest Increasing Subsequence
Breadth-First Search (BFS) for Maze Solving
Merge Sort Algorithm
Knapsack Problem (0/1 Knapsack)
Binary Search for a Sorted Array
Detect Cycle in a Directed Graph (DFS)
1. Binary Search Tree Operations (Insert, Delete, Traversal)
Description: Implement Binary Search Tree (BST) operations including insertion, deletion, and in-order, pre-order, and post-order traversals.
Code: BST Operations
Key Concepts: Tree data structure, recursion
Time Complexity: Average case O(log n), worst case O(n)
2. AVL Tree (Self-Balancing Binary Search Tree)
Description: AVL tree implementation to maintain balanced BSTs by performing rotations during insertion.
Code: AVL Tree
Key Concepts: Self-balancing trees, tree rotations
Time Complexity: O(log n) for insertions, deletions, and searches
3. Heap (Min Heap & Max Heap) Implementation
Description: Min-heap and max-heap implementations with heap operations such as insert and extract.
Code: Heap Implementation
Key Concepts: Binary heaps, priority queues
Time Complexity: O(log n) for insertion and extraction
4. Trie Data Structure (Prefix Tree)
Description: Trie implementation for efficient prefix-based searching and word insertion.
Code: Trie Data Structure
Key Concepts: Tree, searching
Time Complexity: O(n) for search and insertion where n is the length of the word
5. Graph (Adjacency List Representation)
Description: Graph implementation using adjacency lists and traversals using BFS and DFS.
Code: Graph Implementation
Key Concepts: Graph, BFS, DFS
Time Complexity: O(V + E) where V is vertices and E is edges
6. Dijkstra’s Shortest Path Algorithm
Description: Dijkstra’s algorithm to compute the shortest paths in a weighted graph.
Code: Dijkstra's Algorithm
Key Concepts: Graph, shortest path, priority queue
Time Complexity: O(E log V) where V is vertices and E is edges
7. Topological Sorting (Directed Acyclic Graph)
Description: Topological sorting using DFS for directed acyclic graphs (DAG).
Code: Topological Sort
Key Concepts: Graph, DFS, topological order
Time Complexity: O(V + E)
8. Dynamic Programming - Longest Increasing Subsequence
Description: Solve the longest increasing subsequence problem using dynamic programming.
Code: LIS using DP
Key Concepts: Dynamic programming, subsequences
Time Complexity: O(n²)
9. Breadth-First Search (BFS) for Maze Solving
Description: Solve a maze using BFS to find the shortest path from the start to the end.
Code: Maze Solver
Key Concepts: Graph traversal, BFS
Time Complexity: O(V + E)
10. Merge Sort Algorithm
Description: Implementation of the merge sort algorithm for sorting an array.
Code: Merge Sort
Key Concepts: Divide and conquer, sorting algorithms
Time Complexity: O(n log n)
11. Knapsack Problem (0/1 Knapsack)
Description: Solve the 0/1 knapsack problem using dynamic programming to maximize the value with given capacity.
Code: Knapsack Problem
Key Concepts: Dynamic programming, optimization
Time Complexity: O(nW) where n is the number of items and W is the knapsack capacity
12. Binary Search for a Sorted Array
Description: Implement binary search to find an element in a sorted array.
Code: Binary Search
Key Concepts: Searching algorithms
Time Complexity: O(log n)
13. Detect Cycle in a Directed Graph using DFS
Description: Detect cycles in a directed graph using depth-first search (DFS).
Code: Cycle Detection
Key Concepts: Graphs, cycle detection, DFS
Time Complexity: O(V + E)

Contact


